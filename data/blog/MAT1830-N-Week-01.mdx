---
title: MAT1830 N week 01
date: '2023-03-19'
tags: ['MAT1830', 'Week 1', 'Notes']
draft: false
summary:
---

# number theory

- pseudorandom number generations
- hash functions
- memory managment
- error correction
- fast arithmetic operations- cryptogtaphy and authentication

an **interger** is a **whole number**. It may be positive or negative or zero

```

. . . . . . , −3, −+2, −1, 0, 1, 2, 3, . . . . . . .

```

the set of all intergers is often written as **Z**

we say that interger **a** divides interger **b** if **b = qa** for some interger **q**

2 divides 6 becuase 6 = 3 x 2

this is the same sa saying division with remainders gives remainder 0

when a divides b we also say

- a is a divisor of b
- a is a factor of a
- b is divisible by a
- b is a multiple of a

## primes

A positive interger **p > 1** is a prime if its only positive interger divisor are **1** and **p**

1 isn't an interger as it would ruin the fundamental theorem of arithmetic

```

Each interger > 1 can be expressed in exactly one way, up to order, as a product of primes

example:

210 = 2 x 3 x 5 x 7

the first few primes are:

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, . . .


```

### recognising primes

if any interger n > 1 has a divisor, it had a divisor that is **larger or equal too the square root of n** because for any divisor, **a is lager then the square root of n** we also have the divisor **n/a, which is smaller then the square root of n**

thus to test whether 1001 is a prime, we only have to see whether any of the numbers **\*2,3,4... smaller or equal too 100** devide **1001** since **the square root of 1001 is less then 101**

this explains a common algorithim for recognising whether n is a prime number.

the algorithm is written with a boolean variable **_prime_**, and **n** is prime if **_prime_** **= true(T)** when the algorithm terminates

assign **a** the value of **2**
assign **_prime_** the value of **T**
while **a smaller or equal too the square root of n** and **_prime_** **= T**
if **a/n**
give **_prime_** the value **False(F)**
else:
increase the value of **a** by **1**

so:

```py

a = 2
prime = True
while a math.sqrt(n):
    if a / n:
        prime = False
    else:
        a += 1

```

### finding divisors

this algorith also finds a prime devisor of **n**
Either:

- the lease **a** that is **equal to or less then** the square root of **n**

- if we do not find a divisor among the **a** that is **equal to or less then** the square root of **n**, **n** itseslf is prime.

definition:

suppose **m** and **n** are positive intergers. Then a common **divisor** of **m** and **n** is an interger which divides both **m** and **n**

- the common divisor of **30** and **45** are **1,3,5,15**(and thier negatives)

definition:

suppose **m** and **n** are positive intergers. The the **greatest common divisor (gcd)** of **m** and **n** is the greates interger which is a common divisor of **m** and **n**

Example:

- gcd(30,45) = 15
- gcd(13,21) = 1
- gcd(15,21) = 3

note: gcd(a,b) = gcd(b,a) for an intergers **a** and **b**

## the greatest common divisor of two numbers

this is dont with the euclidean algorithm:

the **input** would be a **postive interger m, and n with m being more or equal too n**
the **output** would be the **gcd of m and n**

**a** = **m**, **b** = **n**
**r** = remainder when **a** is divided by **b**
while r **is not** equal to 0:

- a = b
- b = r
- r = remainder when **a** is diveded by **b**

the **end** would be **return b**

example:

```

find gcd(165,120):

165 = 1 * 120 + 45
120 = 2 * 45 + 30
45 = 1 * 30 + 15
30 = 2 * 15 + 0

so gcd(165,120) = 15

```

**Fact:** gcd(a-kb,b) = gcd(a.b) for any positive intergers a, b, k.

**Proof:** if **d** is a common divisor of **a** and **b** then **d** is a common divisor of **a - kb** and **b**

if **e** is a common divisor of **a - kb** and **b** then **d** is a common divisor and **b**(note a = (a - kb) + kb)

So the list of common divisors of **a - kb** and **b** is exactly the same as the list of common divisors of **a** and **b**

So the greatest common divisor of **a - kb** and **b** is equal to the greatest common divisor of **a** and **b**

### The Euclidean algorithm works!

we start with the precondition **m** is bigger or equal to **n** and **n** is bigger then 0
then the divisor thereom tells us there is a remainder **r** that is bigger then **b** when **a** is equal to **m** is divided by **b** which is equal to **n**

if we use the Euclidean algorith for gcd(a,b) = d the we can work backwards to find intergers **a** and **b**

using **am** + **bn** = **d**

find intergers **A** and **b** such that **353a** + **78b** = 1:

353 = 4 _ 78 + 41
78 = 1 _ 41 + 37
41 = 1 _ 37 + 4
37 = 9 _ 4 + 1
4 = 4 \* 1 + 0
